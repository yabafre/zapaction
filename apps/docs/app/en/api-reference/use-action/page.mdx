# useAction

Minimal React hook for executing server actions with state tracking.

```ts
import { useAction } from "@zapaction/react";
```

## Signature

```ts
function useAction<TInput, TOutput>(
  action: DefinedAction<TInput, TOutput>,
): UseActionResult<TInput, TOutput>
```

## UseActionResult

| Property | Type | Description |
|----------|------|-------------|
| `execute` | `(input: TInput) => Promise<TOutput>` | Call the server action |
| `data` | `TOutput \| undefined` | Last successful result |
| `error` | `unknown` | Last error |
| `status` | `ActionStatus` | `"idle"` \| `"pending"` \| `"success"` \| `"error"` |
| `isIdle` | `boolean` | `true` when no action has been called |
| `isPending` | `boolean` | `true` during execution |
| `isSuccess` | `boolean` | `true` after successful execution |
| `isError` | `boolean` | `true` after failed execution |
| `reset` | `() => void` | Reset to idle state |

## Example

```tsx
"use client";

import { useAction } from "@zapaction/react";
import { createUser } from "./actions";

function CreateUserForm() {
  const { execute, isPending, isError, error } = useAction(createUser);

  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const form = new FormData(e.currentTarget);
    try {
      await execute({ name: form.get("name") as string });
    } catch {
      // error is also available via the hook
    }
  };

  return (
    <form onSubmit={onSubmit}>
      <input name="name" required />
      <button disabled={isPending}>
        {isPending ? "Creating..." : "Create"}
      </button>
      {isError && <p>Error: {String(error)}</p>}
    </form>
  );
}
```

## When to use useAction vs useActionMutation

- **useAction**: Simple state tracking, no cache integration
- **useActionMutation**: TanStack Query integration, automatic cache invalidation via tags, optimistic updates
