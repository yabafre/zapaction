# Auth Patterns

ZapAction integrates authentication through context factories and middleware hooks.

## Context factory with auth

Register your auth logic once. Every action receives the result as `ctx`:

```ts
// app/actions.ts
"use server";

import { setActionContext } from "@zapaction/core";
import { auth } from "./auth"; // your auth library

setActionContext(async () => {
  const session = await auth();
  return {
    userId: session?.user?.id ?? null,
    role: session?.user?.role ?? "anonymous",
  };
});
```

## Protected actions with `beforeAction`

Guard sensitive actions:

```ts
export const deleteTodo = defineAction({
  name: "deleteTodo",
  input: z.object({ id: z.string() }),
  output: z.object({ deleted: z.boolean() }),
  tags: ["todos"],
  beforeAction: ({ ctx }) => {
    if (!ctx.userId) throw new Error("Authentication required");
  },
  handler: async ({ input }) => {
    await db.todo.delete({ where: { id: input.id } });
    return { deleted: true };
  },
});
```

## Reusable auth wrapper

Create a helper to DRY up auth guards:

```ts
import { defineAction, type DefineActionOptions } from "@zapaction/core";

type AppContext = { userId: string | null; role: string };

function protectedAction<TInput, TOutput>(
  options: DefineActionOptions<TInput, TOutput, AppContext>,
) {
  return defineAction({
    ...options,
    beforeAction: async ({ input, ctx }) => {
      if (!ctx.userId) throw new Error("Authentication required");
      await options.beforeAction?.({ input, ctx });
    },
  });
}

function adminAction<TInput, TOutput>(
  options: DefineActionOptions<TInput, TOutput, AppContext>,
) {
  return defineAction({
    ...options,
    beforeAction: async ({ input, ctx }) => {
      if (!ctx.userId) throw new Error("Authentication required");
      if (ctx.role !== "admin") throw new Error("Admin access required");
      await options.beforeAction?.({ input, ctx });
    },
  });
}
```

Usage:

```ts
// Only authenticated users
export const createTodo = protectedAction({
  name: "createTodo",
  input: z.object({ title: z.string().min(1) }),
  output: todoSchema,
  tags: ["todos"],
  handler: async ({ input, ctx }) => {
    return db.todo.create({ data: { ...input, userId: ctx.userId! } });
  },
});

// Only admins
export const deleteAllTodos = adminAction({
  name: "deleteAllTodos",
  input: z.object({}),
  output: z.object({ count: z.number() }),
  tags: ["todos"],
  handler: async () => {
    const { count } = await db.todo.deleteMany();
    return { count };
  },
});
```

## Per-action authorization

For fine-grained checks, put the logic directly in `beforeAction`:

```ts
export const updateTodo = defineAction({
  name: "updateTodo",
  input: z.object({ id: z.string(), title: z.string().min(1) }),
  output: todoSchema,
  tags: ["todos"],
  beforeAction: async ({ input, ctx }) => {
    if (!ctx.userId) throw new Error("Not authenticated");
    const todo = await db.todo.findUnique({ where: { id: input.id } });
    if (todo?.userId !== ctx.userId) {
      throw new Error("You can only edit your own todos");
    }
  },
  handler: async ({ input }) => {
    return db.todo.update({ where: { id: input.id }, data: { title: input.title } });
  },
});
```
