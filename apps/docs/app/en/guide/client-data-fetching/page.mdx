# React Query

For client-side reads, pair `@zapaction/query` with `@tanstack/react-query` to keep your server actions and query cache aligned.

<Callout type="warning">
  Server Actions are great for mutations. For high-volume reads, use route handlers or APIs when needed and keep query behavior explicit.
</Callout>

<Callout>
  The docs below follow the same mental model as your UI: one query key strategy, one invalidation strategy, one visible state model.
</Callout>

## Installation

Start by installing both packages:

```bash filename="terminal"
pnpm add @zapaction/query @tanstack/react-query
```

Create a provider and initialize the registry once:

```tsx filename="app/providers.tsx"
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { setTagRegistry } from "@zapaction/query";
import { useState } from "react";

import { appKeys } from "./query-keys";

setTagRegistry({
  todos: [appKeys.todos()],
});

export function AppProviders({ children }: { children: React.ReactNode }) {
  const [client] = useState(() => new QueryClient());
  return <QueryClientProvider client={client}>{children}</QueryClientProvider>;
}
```

## Usage

In a client component:

1. Import your server action and query key.
2. Use `useActionQuery` with `readPolicy: "read-only"`.
3. Use `useActionMutation` for writes so tags invalidate related queries.
4. Render loading, success, and error states explicitly.

```tsx filename="components/todo-panel.tsx"
"use client";

import { useActionMutation, useActionQuery } from "@zapaction/query";

import { createTodo, listTodos } from "../app/actions";
import { appKeys } from "../app/query-keys";

const { data: todos, isPending, isError } = useActionQuery(listTodos, {
  input: {},
  queryKey: appKeys.todos(),
  readPolicy: "read-only",
});

const createMutation = useActionMutation(createTodo);
```

Result preview:

<LiveHelloCard locale="en" />

As shown above, state transitions stay explicit and testable while keeping the API surface small.
