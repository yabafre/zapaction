# Middleware

Use `beforeAction` and `afterAction` to intercept the action pipeline.

## Pipeline

```
Parse Input → Resolve Context → beforeAction → Handler → afterAction → Validate Output → Revalidate Tags
```

## beforeAction

Runs **before** the handler. Throw to abort.

```ts
export const deleteTodo = defineAction({
  name: "deleteTodo",
  input: z.object({ id: z.string() }),
  output: z.object({ deleted: z.boolean() }),
  tags: ["todos"],
  beforeAction: ({ input, ctx }) => {
    if (!ctx.userId) throw new Error("Authentication required");
  },
  handler: async ({ input }) => {
    await db.todo.delete({ where: { id: input.id } });
    return { deleted: true };
  },
});
```

### What you can do in `beforeAction`

| ✅ Do | ❌ Don't |
|-------|---------|
| Validate auth/permissions | Modify input (it's read-only) |
| Log the incoming call | Return a value (it's void) |
| Throw to abort | Run heavy async work |

## afterAction

Runs **after** the handler, before output validation. Return a value to replace the result.

```ts
export const listTodos = defineAction({
  name: "listTodos",
  input: z.object({}),
  output: z.array(todoSchema),
  afterAction: ({ result }) => {
    // Sort by newest first
    return result.sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
    );
  },
  handler: async () => db.todo.findMany(),
});
```

### What you can do in `afterAction`

| ✅ Do | ❌ Don't |
|-------|---------|
| Transform or filter the result | Skip validation (output schema still applies) |
| Log the result | Cause side effects that could fail silently |
| Return `undefined` to passthrough | |

## Composing middleware

Create reusable wrappers for common patterns:

```ts
import { defineAction, type DefineActionOptions } from "@zapaction/core";

type AppContext = { userId: string };

function protectedAction<TInput, TOutput>(
  options: DefineActionOptions<TInput, TOutput, AppContext>,
) {
  return defineAction({
    ...options,
    beforeAction: async ({ input, ctx }) => {
      if (!ctx.userId) throw new Error("Authentication required");
      // Chain with the action's own beforeAction if provided
      if (options.beforeAction) {
        await options.beforeAction({ input, ctx });
      }
    },
  });
}

// Usage
export const deleteTodo = protectedAction({
  name: "deleteTodo",
  input: z.object({ id: z.string() }),
  output: z.object({ deleted: z.boolean() }),
  tags: ["todos"],
  handler: async ({ input }) => {
    await db.todo.delete({ where: { id: input.id } });
    return { deleted: true };
  },
});
```

See the [Middleware API Reference](/en/api-reference/middleware) for type details.
