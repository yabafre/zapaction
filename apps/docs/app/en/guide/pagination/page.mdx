# Pagination

Use `useActionQuery` with pagination parameters for offset or cursor-based patterns.

## Offset pagination

### Action

```ts
export const listTodos = defineAction({
  name: "listTodos",
  input: z.object({
    page: z.number().int().min(1).default(1),
    limit: z.number().int().min(1).max(100).default(20),
  }),
  output: z.object({
    items: z.array(todoSchema),
    total: z.number(),
    page: z.number(),
    totalPages: z.number(),
  }),
  tags: ["todos"],
  handler: async ({ input }) => {
    const skip = (input.page - 1) * input.limit;
    const [items, total] = await Promise.all([
      db.todo.findMany({ skip, take: input.limit, orderBy: { createdAt: "desc" } }),
      db.todo.count(),
    ]);
    return {
      items,
      total,
      page: input.page,
      totalPages: Math.ceil(total / input.limit),
    };
  },
});
```

### Query keys

```ts
const todoKeys = createFeatureKeys("todos", {
  list: (page: number) => [page],
});
```

### Component

```tsx
function TodoList() {
  const [page, setPage] = useState(1);

  const { data, isPending } = useActionQuery(listTodos, {
    input: { page, limit: 20 },
    queryKey: todoKeys.list(page),
    readPolicy: "read-only",
  });

  return (
    <div>
      {data?.items.map((todo) => (
        <div key={todo.id}>{todo.done ? "✓" : "○"} {todo.title}</div>
      ))}
      <button disabled={page <= 1} onClick={() => setPage(page - 1)}>
        Previous
      </button>
      <span>{page} / {data?.totalPages}</span>
      <button
        disabled={page >= (data?.totalPages ?? 1)}
        onClick={() => setPage(page + 1)}
      >
        Next
      </button>
    </div>
  );
}
```

## Cursor pagination

### Action

```ts
export const listTodos = defineAction({
  name: "listTodos",
  input: z.object({
    cursor: z.string().optional(),
    limit: z.number().int().min(1).max(50).default(20),
  }),
  output: z.object({
    items: z.array(todoSchema),
    nextCursor: z.string().nullable(),
  }),
  tags: ["todos"],
  handler: async ({ input }) => {
    const items = await db.todo.findMany({
      take: input.limit + 1,
      ...(input.cursor && { cursor: { id: input.cursor }, skip: 1 }),
      orderBy: { createdAt: "desc" },
    });
    const hasMore = items.length > input.limit;
    return {
      items: hasMore ? items.slice(0, -1) : items,
      nextCursor: hasMore ? items[items.length - 1].id : null,
    };
  },
});
```

### Component with infinite query

For cursor-based pagination, use TanStack Query's `useInfiniteQuery` directly with the action:

```tsx
import { useInfiniteQuery } from "@tanstack/react-query";

function TodoFeed() {
  const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({
    queryKey: ["todos"],
    queryFn: ({ pageParam }) => listTodos({ cursor: pageParam, limit: 20 }),
    initialPageParam: undefined as string | undefined,
    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,
  });

  return (
    <div>
      {data?.pages.flatMap((p) => p.items).map((todo) => (
        <div key={todo.id}>{todo.done ? "✓" : "○"} {todo.title}</div>
      ))}
      {hasNextPage && <button onClick={() => fetchNextPage()}>Load more</button>}
    </div>
  );
}
```
