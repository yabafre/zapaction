# useAction

Hook React minimal pour exécuter des server actions avec suivi d'état.

```ts
import { useAction } from "@zapaction/react";
```

## Signature

```ts
function useAction<TInput, TOutput>(
  action: DefinedAction<TInput, TOutput>,
): UseActionResult<TInput, TOutput>
```

## UseActionResult

| Propriété | Type | Description |
|-----------|------|-------------|
| `execute` | `(input: TInput) => Promise<TOutput>` | Appeler la server action |
| `data` | `TOutput \| undefined` | Dernier résultat réussi |
| `error` | `unknown` | Dernière erreur |
| `status` | `ActionStatus` | `"idle"` \| `"pending"` \| `"success"` \| `"error"` |
| `isIdle` | `boolean` | `true` quand aucune action n'a été appelée |
| `isPending` | `boolean` | `true` pendant l'exécution |
| `isSuccess` | `boolean` | `true` après exécution réussie |
| `isError` | `boolean` | `true` après exécution échouée |
| `reset` | `() => void` | Réinitialiser à l'état idle |

## Exemple

```tsx
"use client";

import { useAction } from "@zapaction/react";
import { createUser } from "./actions";

function CreateUserForm() {
  const { execute, isPending, isError, error } = useAction(createUser);

  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const form = new FormData(e.currentTarget);
    try {
      await execute({ name: form.get("name") as string });
    } catch {
      // l'erreur est aussi disponible via le hook
    }
  };

  return (
    <form onSubmit={onSubmit}>
      <input name="name" required />
      <button disabled={isPending}>
        {isPending ? "Création..." : "Créer"}
      </button>
      {isError && <p>Erreur : {String(error)}</p>}
    </form>
  );
}
```

## Quand utiliser useAction vs useActionMutation

- **useAction** : Suivi d'état simple, pas d'intégration cache
- **useActionMutation** : Intégration TanStack Query, invalidation automatique du cache via tags, mises à jour optimistes
