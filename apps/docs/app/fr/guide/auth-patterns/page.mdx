# Auth Patterns

ZapAction intègre l'authentification via les context factories et les hooks middleware.

## Context factory avec auth

Enregistrez votre logique d'auth une fois. Chaque action reçoit le résultat via `ctx` :

```ts
// app/actions.ts
"use server";

import { setActionContext } from "@zapaction/core";
import { auth } from "./auth";

setActionContext(async () => {
  const session = await auth();
  return {
    userId: session?.user?.id ?? null,
    role: session?.user?.role ?? "anonymous",
  };
});
```

## Actions protégées avec `beforeAction`

```ts
export const deleteTodo = defineAction({
  name: "deleteTodo",
  input: z.object({ id: z.string() }),
  output: z.object({ deleted: z.boolean() }),
  tags: ["todos"],
  beforeAction: ({ ctx }) => {
    if (!ctx.userId) throw new Error("Authentification requise");
  },
  handler: async ({ input }) => {
    await db.todo.delete({ where: { id: input.id } });
    return { deleted: true };
  },
});
```

## Wrapper d'auth réutilisable

```ts
import { defineAction, type DefineActionOptions } from "@zapaction/core";

type AppContext = { userId: string | null; role: string };

function protectedAction<TInput, TOutput>(
  options: DefineActionOptions<TInput, TOutput, AppContext>,
) {
  return defineAction({
    ...options,
    beforeAction: async ({ input, ctx }) => {
      if (!ctx.userId) throw new Error("Authentification requise");
      await options.beforeAction?.({ input, ctx });
    },
  });
}

function adminAction<TInput, TOutput>(
  options: DefineActionOptions<TInput, TOutput, AppContext>,
) {
  return defineAction({
    ...options,
    beforeAction: async ({ input, ctx }) => {
      if (!ctx.userId) throw new Error("Authentification requise");
      if (ctx.role !== "admin") throw new Error("Accès admin requis");
      await options.beforeAction?.({ input, ctx });
    },
  });
}
```

Utilisation :

```ts
// Utilisateurs authentifiés uniquement
export const createTodo = protectedAction({
  name: "createTodo",
  input: z.object({ title: z.string().min(1) }),
  output: todoSchema,
  tags: ["todos"],
  handler: async ({ input, ctx }) => {
    return db.todo.create({ data: { ...input, userId: ctx.userId! } });
  },
});

// Admins uniquement
export const deleteAllTodos = adminAction({
  name: "deleteAllTodos",
  input: z.object({}),
  output: z.object({ count: z.number() }),
  tags: ["todos"],
  handler: async () => {
    const { count } = await db.todo.deleteMany();
    return { count };
  },
});
```

## Autorisation par action

```ts
export const updateTodo = defineAction({
  name: "updateTodo",
  input: z.object({ id: z.string(), title: z.string().min(1) }),
  output: todoSchema,
  tags: ["todos"],
  beforeAction: async ({ input, ctx }) => {
    if (!ctx.userId) throw new Error("Non authentifié");
    const todo = await db.todo.findUnique({ where: { id: input.id } });
    if (todo?.userId !== ctx.userId) {
      throw new Error("Vous ne pouvez modifier que vos propres todos");
    }
  },
  handler: async ({ input }) => {
    return db.todo.update({ where: { id: input.id }, data: { title: input.title } });
  },
});
```
