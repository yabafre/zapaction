# Mises à jour optimistes

Utilisez le pattern `onMutate` de TanStack Query avec `useActionMutation` pour un retour UI instantané.

## Basculer un todo (optimiste)

```tsx
import { useQueryClient } from "@tanstack/react-query";
import { useActionMutation, useActionQuery } from "@zapaction/query";
import { toggleTodo, listTodos } from "../app/actions";
import { appKeys } from "../app/query-keys";

function TodoList() {
  const queryClient = useQueryClient();

  const { data: todos = [] } = useActionQuery(listTodos, {
    input: {},
    queryKey: appKeys.todos(),
    readPolicy: "read-only",
  });

  const mutation = useActionMutation(toggleTodo, {
    onMutate: async (input) => {
      // 1. Annuler les refetch en cours
      await queryClient.cancelQueries({ queryKey: appKeys.todos() });

      // 2. Snapshot des données actuelles
      const previous = queryClient.getQueryData(appKeys.todos());

      // 3. Mise à jour optimiste
      queryClient.setQueryData(appKeys.todos(), (old: typeof todos) =>
        old.map((t) => (t.id === input.id ? { ...t, done: !t.done } : t)),
      );

      return { previous };
    },
    onError: (_err, _input, context) => {
      // 4. Rollback en cas d'erreur
      if (context?.previous) {
        queryClient.setQueryData(appKeys.todos(), context.previous);
      }
    },
  });

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => mutation.mutate({ id: todo.id })}>
          {todo.done ? "✓" : "○"} {todo.title}
        </li>
      ))}
    </ul>
  );
}
```

## Comment ça marche

```
L'utilisateur clique sur "basculer"
  ↓
onMutate se déclenche → l'UI se met à jour instantanément (optimiste)
  ↓
La server action s'exécute (toggleTodo)
  ↓ succès                           ↓ erreur
L'invalidation par tags rafraîchit   onError revient au snapshot
avec les données serveur
```

## Ajouter un todo (optimiste)

```tsx
const mutation = useActionMutation(createTodo, {
  onMutate: async (input) => {
    await queryClient.cancelQueries({ queryKey: appKeys.todos() });
    const previous = queryClient.getQueryData(appKeys.todos());

    queryClient.setQueryData(appKeys.todos(), (old: Todo[]) => [
      { id: `temp-${Date.now()}`, title: input.title, done: false },
      ...old,
    ]);

    return { previous };
  },
  onError: (_err, _input, context) => {
    if (context?.previous) {
      queryClient.setQueryData(appKeys.todos(), context.previous);
    }
  },
});
```

## Points clés

- Toujours annuler les queries en cours avant la mise à jour optimiste
- Toujours sauvegarder les données précédentes pour le rollback
- Après le succès, l'invalidation par tags se déclenche toujours — les données serveur remplacent les données optimistes
- Le contexte `onMutate` est disponible dans `onError` et `onSettled`
