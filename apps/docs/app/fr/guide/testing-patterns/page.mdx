# Patterns de test

Les actions ZapAction sont des fonctions async simples, donc teste le contrat directement avec Vitest.

## Tester une action

```ts filename="features/todos/actions.test.ts"
import { beforeEach, describe, expect, it, vi } from "vitest";
import { __resetActionContextForTests, setActionContext } from "@zapaction/core";
import { createTodo } from "./actions";

vi.mock("next/cache", () => ({
  revalidateTag: vi.fn(),
}));

describe("createTodo", () => {
  beforeEach(() => {
    __resetActionContextForTests();
    setActionContext(async () => ({ userId: "test-user" }));
  });

  it("cree un todo avec un input valide", async () => {
    const result = await createTodo({ title: "Ecrire des tests" });
    expect(result).toMatchObject({ title: "Ecrire des tests", done: false });
    expect(result.id).toBeDefined();
  });

  it("rejette un titre vide", async () => {
    await expect(createTodo({ title: "" })).rejects.toThrow();
  });
});
```

## Tester les hooks

```ts filename="packages/react/src/useAction.test.ts"
import { beforeEach, describe, expect, it, vi } from "vitest";
import { useAction } from "@zapaction/react";

let stateMap: Map<number, unknown>;
let stateIndex: number;

vi.mock("react", () => ({
  useState: (initial: unknown) => {
    const idx = stateIndex++;
    if (!stateMap.has(idx)) stateMap.set(idx, initial);
    return [stateMap.get(idx), (next: unknown) => stateMap.set(idx, next)];
  },
  useCallback: (fn: Function) => fn,
}));

beforeEach(() => {
  stateIndex = 0;
  stateMap = new Map();
});

it("retourne un etat initial idle", () => {
  const action = async (input: { title: string }) => ({
    id: "1",
    title: input.title,
    done: false,
  });
  const result = useAction(action);
  expect(result.status).toBe("idle");
});
```

## Tester l'invalidation des mutations

```ts filename="packages/query/src/useActionMutation.test.ts"
import { vi } from "vitest";
import { useActionMutation } from "@zapaction/query";

vi.mock("@tanstack/react-query", () => ({
  useQueryClient: () => ({ invalidateQueries: vi.fn() }),
  useMutation: (opts: any) => ({
    mutateAsync: async (input: unknown) => {
      const data = await opts.mutationFn(input);
      if (opts.onSuccess) await opts.onSuccess(data, input, undefined, undefined);
      return data;
    },
  }),
}));
```

## Verification live

<LiveTestResults locale="fr" />

Garde les tests centres sur le comportement observable:

- Mock des frontieres externes (`next/cache`, reseau, db).
- Reset du contexte partage dans `beforeEach`.
- Validation des contrats input/output avant les details internes.
