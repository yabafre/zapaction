# Introduction

ZapAction est une couche de contrats typés pour les **Next.js Server Actions** et **TanStack Query**.

Il fournit un modèle partagé pour :

- Valider les entrées/sorties d'actions avec `defineAction` + Zod
- Structurer les query keys et cache tags
- Invalider le cache automatiquement côté serveur et client
- Standardiser les patterns d'équipe : hooks, middleware, gestion d'erreurs

## Comment ça marche

```
┌─────────────────────────────────────────────────────────────┐
│  defineAction({ input, output, tags, handler })             │
│  → valide l'input → exécute le handler → valide l'output   │
│  → revalide les tags serveur → déclenche les queries client │
└─────────────────────────────────────────────────────────────┘
```

1. **Définir** le contrat de l'action côté serveur avec `defineAction`
2. **Lire** les données côté client avec `useActionQuery`
3. **Écrire** avec `useActionMutation` — les tags invalident automatiquement les queries
4. **Gérer les erreurs** avec `ActionErrorBoundary` et `useActionErrorReset`

## Aperçu en 10 lignes

```ts
// Serveur : définir une action typée
export const createTodo = defineAction({
  input: z.object({ title: z.string().min(1) }),
  output: todoSchema,
  tags: ["todos"],
  handler: async ({ input }) => db.todo.create({ data: input }),
});

// Client : mutation avec auto-invalidation
const mutation = useActionMutation(createTodo);
await mutation.mutateAsync({ title: "Acheter du lait" });
// → cache serveur revalidé, query client rafraîchie
```

## Parcours de la documentation

1. Commencez par le [Quick Start](/fr/guide/project-setup) — installation + première action en 2 minutes
2. Explorez le [Data Fetching](/fr/guide/client-data-fetching) — lectures, écritures, invalidation
3. Lancez l'[Exemple CRUD Complet](/fr/examples/full-crud) — une vraie app Next.js à tester localement
4. Consultez la [Référence API](/fr/api-reference) pour les détails
