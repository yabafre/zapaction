---
title: "Middleware"
description: "Use beforeAction and afterAction hooks for policy, audit, and shaping output."
---

# Middleware

## beforeAction

Use `beforeAction` for authorization checks, audit prep, or guard clauses.

```ts app/actions/todos.ts
import { defineAction } from "@zapaction/core";
import { z } from "zod";

type AppContext = { userId: string; role: "admin" | "user" };

export const archiveTodo = defineAction<
  { id: string },
  { ok: true },
  AppContext
>({
  input: z.object({ id: z.string() }),
  output: z.object({ ok: z.literal(true) }),
  beforeAction: async ({ ctx }) => {
    if (ctx.role !== "admin") {
      throw new Error("Forbidden");
    }
  },
  handler: async () => ({ ok: true })
});
```

## afterAction

Use `afterAction` to sanitize or shape the final response.

```ts app/actions/users.ts
import { defineAction } from "@zapaction/core";
import { z } from "zod";

export const getUser = defineAction({
  input: z.object({ id: z.string() }),
  output: z.object({ id: z.string(), email: z.string() }),
  afterAction: async ({ result }) => ({
    ...result,
    email: result.email.toLowerCase()
  }),
  handler: async ({ input }) => ({
    id: input.id,
    email: "USER@EXAMPLE.COM"
  })
});
```

## Order of execution

1. `input.parse`
2. `resolveActionContext`
3. `beforeAction`
4. `handler`
5. `afterAction`
6. `output.parse`
7. `revalidateTags`
